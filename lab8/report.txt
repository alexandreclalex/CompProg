Alexandre Clavel
David Yang
Nathan Dupont

Airport Coffee
    Document what the problem is asking for in your own words
        A person is attempting to walk through the airport to get to their gate, along the way they stop for coffee which increased their speed.
        Given the distance they need to walk, the speed they walk at with and without coffee, the time it takes before drinking and the time it takes to drink.
        Find when the person should stop for coffee at the given coffee shops along the way.

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
       I used a while loop to increment when the person should stop to drink the coffee and then increment the total distance by how far the person has traveled.
       This runs into the issue of iterating through too many times since the distance can be over 10^11 but the person moves only 135 cm per iteration.

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
       8907887 01:16:11	Airport Coffee	Time Limit Exceeded	> 4.00 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        Since you are iterating through the distances
        Time complexity: O(n)

        To store the cart locations requires O(n) memory.
        Memory complexity:O(n)

    What optimizations (if any) did you implement?
        Trying to find the next closest cart is tricky that I(David) was unable to solve. Also to avoid iterating through the while loop will help as well. Maybe
        there is another way to go around this.

CrissCross
    Document what the problem is asking for in your own words
        Given many line segments, what is the number of distinct intersections of the segments

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Read in lines
        For each pair of lines, check if there is an intersection.
            If there is no intersection, they are either parallel, or coincident
                Check if the lines are parallel
                Check if axis intercepts are the same
                If the lines are coincident, check if they overlap
                Find the largest distance (d) between 2 points, and the sum of the lengths of the 2 segments (SoS)
                If d > SoS: no intersection
                If d = SoS: one intersection
                If d < SoS: infinite intersections
                Add the intersection to a set
        Output the size of the set
        If there is an infinite amount of intersections, we print -1 and exit

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8877598	2022-04-27 11:06:09	Criss-Cross	✅Accepted	3.55 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of lines
        Time complexity: O(n^2)
            Need to check all of the pairs of lines
        Memory complexity: O(n^2)
            At worst, every line will have a distinct intersection

    What optimizations (if any) did you implement?
        Using set allows for Python to deal with deduplication

DNA
    Document what the problem is asking for in your own words
        Given a sequence of a's and b's, while being able to flip one bit or a series of bits, 
        what is the minimum amout of steps to make the sequence all a's

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        First flip all groups of one charachter
        Then count the number of groups
        If the last group is B, add one move to make it A

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8877763	2022-04-27 11:40:51	DNA	✅Accepted	0.16 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = length of the sequence
        Time complexity: O(n)
            Need to iterate through the entire sequence
        Memory complexity: O(n)
            Need to store sequence in an array

    What optimizations (if any) did you implement?
        Flipping single bits made the code easier to implement

Jumping Yoshi
    Document what the problem is asking for in your own words
        Given a sequence of stones and the stipulation that you may only jump from a to b 
        if the number of pips on a and b is equal to the distance between a and b, what is the furthest you can get

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Create a graph of nodes reachable from all points at the beginning
        Do a bfs to mark all reachable nodes
        Find the righmost node that is reachable

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8903947	01:23:53	Jumping Yoshi	✅Accepted	0.32 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of pebbles
        Time complexity: O(n)
            Need to iterate through all pebbles in bfs
        Memory complexity: O(n^2)
            Worst case, all nodes are reachable by all other nodes

    What optimizations (if any) did you implement?
        By only creating a list when a node needs to be added, we save on memory

Product Digit
    Document what the problem is asking for in your own words
        Given a and b, what is the occurrence of each digit when digits are recursively multiplied

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        We know that after one iteration, the only prime factors are 2, 3, 5, and 7
        Thus we can cache the results for all results after one step, there are only 33k
        Then we iterate from a to b, and count the occurrences of digits

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        We were not able to solve without a TLE

    What is the runtime complexity and memory complexity of your solution?
        Time complexity: O(b-a)
            We need to iterate through all numbers between a and b
        Memory complexity: O(1)
            We only store the digit counts, so constant memory

    What optimizations (if any) did you implement?
        Caching the results after one step speeds up calculation immensly

Taboo
    Document what the problem is asking for in your own words
        This problem is based on the game called "Taboo", where one person has a card with a name or topic, and a list of "taboo"/forbidden words that cannot be said. The person with the card then needs to get the others on their team to guess the word on their card, without anyone saying the forbidden words.

        This problem looks to find the largest legal clue that could be used in a taboo problem (using binary values), where the clue doesn't contain any of the forbidden words as substrings.

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        There were a few algorithms that were designed, but not successfully implemented.

        First algorithm:
            Read in each of the forbidden words, and store them to a set with their integer value.

            Take a string of possible clues, and shift bits onto possible strings that don't match with any of the forbidden words

            Return the final string with possible clues with the longest number of characters

        Second algorithm:
            Read in each of the forbidden words, and add their values to a trie structure

            Create a possible clue bit by bit, only adding possible bits that don't exist in the trie as the end of a clue

            Return the maximum possible clue found


        Both of these algorithms had large time complexities, and I wasn't able to get them working well or get an implementation that worked.

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        We were not able to make something functional within the time limit. This is due to the algorithm testing all possible permutations of inputs, which ended up taking too long.

    What is the runtime complexity and memory complexity of your solution?
        Assumptions:
            Number of clues: n
            Length of longest clue: m

        Time complexity:
            First algorithm: O(n^2 * m)
                Each clue needs to be read in, and from there, each clue needs to be tested against each possible value of the clue. This leads to reading in each value (n) and testing it (n * m).

            Second algorithm: O(n^2 * log(m))
                This algorithm has a similar speed to above, but in using a Trie, it can be accelerated to only check combinations of numbers that exist.

        Memory complexity:
            Both have a complexity of O(n * 2^m), as it stores all of the clues, and all possible permutations of clues that could be possible.

    What optimizations (if any) did you implement?
        The first solution was scrapped and the second solution was used as the Trie would work slightly better when searching through the possible forbidden words, checking one digit at a time instead of searching through every option every time.

    How did other programming languages (if used) affect your submission results?
        This was primarily done in Python to focus on developing the algorithm