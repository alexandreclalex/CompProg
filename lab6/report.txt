Alexandre Clavel
David Yang
Nathan Dupont

Counting Triangles
    Document what the problem is asking for in your own words
        Given a list of line segments, find how many triangles are formed by the segments

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Store all of the lines in an array
        Iterate through all possible groups of 3 lines
            If all 3 lines intersect, add 1 to the counter of triangles
        
        Finding if 2 lines intersect:
            Find where the lines would intersect if they were infinite length
            Verify that the coordinates of the intersection are in the bounds of the segments

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8823307	2022-04-18 00:08:19	Counting Triangles	✅Accepted	0.75 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of line segments
        Runtime: O(n^3)
            If all lines intersect, we need to check all trios of lines
        Memory: O(n)
            We only need to store the lines once, in an array

    What optimizations (if any) did you implement?
        If the first 2 lines in a trio don't intersect, we dont bother finding a third line to complete the trio

Elegant Showroom
    Document what the problem is asking for in your own words
        Given the layout of a car dealer's showroom, find the minimum number of cars you need to move to get a specific car out of the showroom

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        We store the showroom as a 2d array of chars, and replace the charachters with ints as we find how many cars to move to get to any given point
        We store the list of coordinates to explore in a queue, starting with the coordinates of the given car
        We iterate until the queue is empty
            Pop the next coordinate off of the queue
            Iterate through the neighbors
                If the neigbor is a wall, we ignore it
                If the neighbor is a car, we give it the current score + 1, and add it to the queue
                If the neigbor is a door
                    If the door is on the edge, we print out the score and quit
                    If the door is not on the edge, we give it the current score, and add it to the front of the queue

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        We were not able to get kattis to accept our solution, we got the first 5 cases, and fail on the 6th

    What is the runtime complexity and memory complexity of your solution?
        n = number of nodes in the showroom
        Runtime: O(n)
            Worst case, we need to explore all of the nodes in the room to find a path
        Memory: O(n)
            worst case, all the nodes we explore will be in the queue

    What optimizations (if any) did you implement?
        Using a queue, we know that the first solution we find is the best, so we can stop searching, and print the result
 
Erdos Numbers
    Document what the problem is asking for in your own words
        Given a list of co-authorships, find the number of co-authorships required to link an author to Erdos

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Store a list of targets, in which we store the authors whose numbers we need to find
        Store a dict of authors, where the key is the author's name, and the value is a set of co-authors
        Create a dict of scores, and give Erdos a score of 0
        Create a queue to iterate through, and start with Erdos
            Pop the author oof of the queue
            Iterate through the co-authors
                If they do not have a score, or we can improve their score, give them a score of author's score + 1, and add them to the queue

        Iterate through the targets
            If the target has a score, print their score, otherwise print 'no-connection'

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8831687	12:28:31	Erdős Numbers	✅Accepted	0.10 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of authors
        m = maximum Erdos number

        Runtime: O(n * m)
            Worst case, we iterate through the entire authorship tree, with width n and depth m
        Memory: O(n)
            We must store one author entry for all authors named in the problem

    What optimizations (if any) did you implement?
        By using a set, we saved needing to check for duplicates before adding co-authors
 
    How did other programming languages (if used) affect your submission results?
        Python's fast in operator made the code much easier to spped up.

Trip Planning
    Document what the problem is asking for in your own words
        Given a total of N cities that an individual wants to visit in sequential order, and a list of bi-directional train lines between any two of the cities, determine if it is possible to complete the trip, and the order of the train routes that needs to be taken.

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Read in the number of cities, and the number of train lines in the input
        For each of the cities:
            Add the integer to a set indicating the cities that are still unconnected
        For each train line:
            Determine the starting and ending point of the route
            Sort the endpoints to get the lowest and highest number city
            If the endpoints are the starting and ending nodes:
                Mark the return trip as present
            If the endpoints are one city apart and the ending city hasn't been visited:
                Mark the ending city as visited
            Remove the visited nodes from the set

        If there are any cities still remaining in the sequence:
            Print impossible
        Else:
            Print out the connections in the order that they were made

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8802955	2022-04-13 16:52:08	Trip Planning	✅Accepted	1.26 s	Python 3
    
    What is the runtime complexity and memory complexity of your solution?
        Assumptions:
            Number of cities: n
            Number of train lines: m

        This solution iterates through each of the cities to map them to a remaining connection, and then iterates through each of the train lines to determine which cities have possible lines attached to them.

        Finally, if there are connections to every city, each city is iterated through, in order to print out the train lines to each.

        Time complexity: O(2n + m)

        For the memory, this solution just stores integers to represent each of the cities that is present. This leads to a small memory footprint, as each integer is stored within a set. Once a single city is found with a connection, it is moved to a separate set, paired with the route number.

        Memory complexity: O(n)

    What optimizations (if any) did you implement?
        I utilized sets to allow for ordering of the values, hoping to gain a small speed boost over utilizing lists to store the remaining and established connections. 
        
        Utilizing sets, we no longer need to search the cities as a graph for a solution. Instead, since we always want to move one city at a time, we can iterate through all of the paths once, and mark the cities as reachable if they have a path from the previous city to the next. This vastly reduces the time complexity from using a search algorithm, and allowed for effective performance.

    How did other programming languages (if used) affect your submission results?
        Our primary implementation was written in Python, and was able to effectively solve the problem with much less time and memory than the provided constraints.