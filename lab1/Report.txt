Alexandre Clavel
David Yang
Nathan Dupont

Cinema Crowds
    Document what the problem is asking for in your own words
        We are asked to solve a problem scheduling groups into a movie theater, and are asked to report the number of groups that must be turned away from the theater.
        
    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        I stored the group sizes in an array, and the remaining capacity in an int.
        My algorithm is as follows:
            For each group, check if it is less than the remaining capacity in the theater
                If it is, remove capacity from the remaining capacity equal to the group sizes
                Otherwise, add 1 to the number of rejected groups
            Return the number of rejected groups

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8598665	2022-03-09 18:47:06	Cinema Crowds   ✅Accepted	0.05 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of groups that want to enter the Cinema
        Runtime: O(n)
        Memory: O(n)

    What optimizations (if any) did you implement?
        With my implementation in Python, the string is not parsed until needed, which I believe provides a marginal improvment.

    How did other programming languages (if used) affect your submission results?
        Python's built in map was very useful in my implementation. In additon, Python's Input() was very easy to use to read input.


Flood It
    Document what the problem is asking for in your own words
        This problem had us implement a simple greedy solver for the game flood-it. We would then output the number of turns it took the greedy solver.

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        We had 2 implementations for this problem, an array-based implementation and a tree (technically graph) based approach

        Array:
            #TODO: Add detail for array implementation

        Tree:
            First, the tree is initialized in an array, such that each node knows its neighbors
            We then play the best move, over and over again, until the game is over, and record the moves we play:
                Start at the Root node
                For all neighbors to the node, if they have not been visited, visit them, and add them to the set of visited nodes.
                    If they are equal to Root, restart search starting from the node
                    If they are not equal to root, recursively visit all neighbors that have the same number and add them to the list of visited nodes.
                
                Now, we have a set of all nodes that are reachable in the next move.
                We then find the most common number in the set (other than the root number). This is the number we will play. In ties, we pick the lower number.
                If all counts besides the root number are 0, we know the game is over, and do not need to play.
                In order to play, we iterate through the set, and change the number of nodes matching the root number to the number we play.

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        We did not finish in the class period. Here is our results from after class.
        Array:
            #TODO: Add Kattis results
        Tree:
            8599512	2022-03-09 22:12:50	Flood-It	✅Accepted	0.35 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        Array:
            #TODO: Add runtime complexity
        
        Tree:
            n = size of board
            m = number of moves to complete game (This is variable based on board size. Since there are only 6 colors, if n >= 3, the computation becomes non-trivial. I guess it is between nlogn and n^2 but am not sure - Alex)

            Runtime: O(n^2 * m)
            Memory: O(n^2)

    What optimizations (if any) did you implement?
        Tree:
            Having the tree initialized once helped a lot with time complexity

    How did other programming languages (if used) affect your submission results?
        Python's sets and fast "in" operator really helped this problem, as "in" is called a lot.


Flow Layout
    Document what the problem is asking for in your own words

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition

    What is the runtime complexity and memory complexity of your solution?

    What optimizations (if any) did you implement?

    How did other programming languages (if used) affect your submission results?


Popularity Contest
    Document what the problem is asking for in your own words
       This problem is looking for the marketability coefficient of each friend in an attempt to figure out how many friends know one another. Obtaining input from            the user will require the first line to contain N, the number of friends and M, the number of friendships among those friends. Each i'th friend is given a              success factor i. Next task would be to calculate the popularity factor Pi by determining how many friends each one has. Lastly, to find the marketability              coefficient for each friend, find the difference between the popularity factor and success factor.

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
       To accomplish this task, we used while loops and for loops to check for edge cases and iterate through an array. The first step was to get all necessary                information to process such as the number of friends, number of friendships and the popularity factor. The popularity factor is done by storing the number of          times a success factor appears in the pairs given by input. Using the popularity and success factor, we are able to determine each friend’s marketability              coefficient.

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8599247	2022-03-09 22:12:50	Popularity Contest	✅Accepted	0.52 s	Python 3
    What is the runtime complexity and memory complexity of your solution?
        Memory: O(n)
        Runtime: O(n)
    What optimizations (if any) did you implement?
        Instead of having multiple for loops to read in data, process data, then print it. Doing it all in one for loop seems to optimize the program.


