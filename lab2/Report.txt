Alexandre Clavel
David Yang
Nathan Dupont

Hailstone Sequences
    Document what the problem is asking for in your own words
    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
    What is the runtime complexity and memory complexity of your solution?
    What optimizations (if any) did you implement?
    How did other programming languages (if used) affect your submission results?

Hermits
    Document what the problem is asking for in your own words
        Given populations of streets, and intersections of streets, find the street with the least population on itself and all adjoining streets

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        Populations were stored in an array
        Street intersections were stored in a 2d array

        We iterate through the indices, and add the populations of the other streets at crossings
        We then find the minimum adjoining population and print out the corresponding street

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8638778	2022-03-16 17:24:17	Hermits	✅Accepted	0.35 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = number of street intersections. The algorithm may be bound by the number of streets m, 
        but since n can be <= m(m-1)/2, in the worst case, the algorithm is bounded by the number of intersections.
        
        Runtime: O(n)
            We need to iterate through all of the intersections to calculate the solution
        Memory: O(n)
            We need to read in all intersections, and store them in an array of dimenstions m * 2

    What optimizations (if any) did you implement?
        Optimizes data in by using sys.stdin.readline rather than builtin input. We would probably TLE if using input.

Odd A’s, Even B’s
    Document what the problem is asking for in your own words
        Given length n, how many strings of {a, b} can be made where a's are always in odd groups and b's are always in even groups

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        I used a recursive algorithm with a cache to speed up computation.
        If n = 0: we have reached the end of the string, and return 1
        If the result was already computed, return what we calculated before

        I implemented rules based on the last char, using the odd/even properties of 'a' and 'b' respectively:
            'a':
                Add 2 'a', and calculate n - 2
                Add 2 'b', and calculate n - 2
            'b':
                Add 1 'a', and calculate n - 1
                Add 2 'b', and calculate n - 2
            Start of String:
                Add 1 'a', and calculate n - 1
                Add 2 'b', and calculate n - 2
        
        I then cache the result in the cache, and return the result

    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        8638915	2022-03-16 17:47:35	Odd A's, Even B's	✅Accepted	0.06 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = given length
        Runtime: O(n)
            Since we cache the result, and the time to calculate one cache entry is constant, we have the smae complexity for runtime as memory.
        Memory: O(n)
            With caching, we have at most n * 2 cache entries, one for each length and each last char.

    What optimizations (if any) did you implement?
        Adding a cache to the problem greatly improved the runtime, as the solution went from exponential recursion to linear recursion

    How did other programming languages (if used) affect your submission results?
        Python inbuit dict was useful as a quick and easy way to build a cache

Varied Amusements
    Document what the problem is asking for in your own words
        Given n rides to ride and A, B, and C number of each rides, what is the number of possible ways to ride n rides without repeating ride types

    Describe the algorithm and data structure you used to solve (or attempt to solve) the problem
        I used a recursive solution with a cache to store previously calculated results
        First, check if we have a cache hit, if so, return the cached result.
        Next, check if we have reached the total number of rides, if so, return 1

        Next, conditional on the last ride we rode:
            If we just rode a, we can now ride b or c
            If we just rode b, we can now ride a or c
            If we just rode c, we can now ride a or b
            If we have not ridden a ride yet, we can ride all rides.

        Then, cache and return the result
        
    Save the output from your last submission to Kattis (e.g. a screenshot of the web interface) for your last submission during the lab competition
        During lab:
        8639094	2022-03-16 18:21:18	Varied Amusements	✅Accepted (1)	> 1.00 s	Python 3
        After lab:
        8639459	2022-03-16 19:44:05	Varied Amusements	✅Accepted (2)	0.06 s	Python 3

    What is the runtime complexity and memory complexity of your solution?
        n = given length
        Runtime: O(n)
            Since we cache the result, and the time to calculate one cache entry is constant, we have the smae complexity for runtime as memory.
        Memory: O(n)
            With caching, we have at most n * 3 cache entries, one for each length and each last ridden ride

    What optimizations (if any) did you implement?
        Caching the result greatly improved runtime, at the cost of memory

    How did other programming languages (if used) affect your submission results?
        Python dict was useful to make easy cache